# Lab 9:

Lab 9 took me a lot longer than expected because one set of wheels on my robot was not working as intended. Although I was able to temporarily fix this, when I went to collect my data, I realized that the wire connecting one of the motor drivers to the motor had completely come out (not on the motor driver side but on the motor side). This essentially meant that I had no control over one set of wheels, so in order to perform orientation control, I would need to somehow restrict those set of wheels from turning and only let the other set of wheels turn (thus the robot would rotate about the axis of the non-spinning set of wheels). Although this could have been solved mechanically (my jamming the other wheels), due to time constraints, I decided, for the purpose of this lab, to just hold those wheels in place while the other wheels rotated the robot around. Although this wasn't the best solution because it wasn't turning very well, I decided to continue with this temporary solution for the sake of understanding how mapping works even if it wouldn't be the most accurate map. I had also originally tried velocity control when both sets of wheels were working, but then, I was having issues with my controller itself (which I later fixed but my wheels were then not working). Overall, the issues with my motors meant that I didn't necessarily get the best results that I wanted, but I'm super thankful for Larry for hosting OH super last minute so that I could spend some time to at least try getting a map + Jonathan for letting me use the room!!

# PID Orientation Control

I first started with PID Orientation Control of the robot's one set of wheels to enable on axis turns. The code for it is listed below. I had originally tried working with Velocity Control, but I realized that because the velocity wouldn't be super accurate, this was messing up my map. With Orientation Control, I created a for loop of each of the angles that I wanted the robot to be at (around 0.436 radians incrementally), and used a P controller to multiply the error of the setpoint by the KP value. I had a threshold for how big the error could be before it exited the inner while loop for error and incremented to the next angle that it would need to reach. At each setpoint, I took 10 ToF readings which I averaged such that I would have a sensor range reading for each sensor bearing. Code for this is shown below:

My sensor does have a lot of drift but not too much based on my IMU testing in earlier labs. Based on how much drift I found in the IMU lab, the average error is probably around 0.05 - 0.1 radians, and the maximum I found while testing in this lab was around 1 radian (which I corrected for by reducing the threshold of how much error was okay before changing the setpoint to the next angle in the full 360 degree rotation).

Here is a video and graph of my robot's PID control:
